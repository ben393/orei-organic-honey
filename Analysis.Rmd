---
title: "Organic honey production may be possible in the Continental U.S."
subtitle: "Data and analysis"
author: 
 - Benedict X. DeMoras^[Cornell University, bd379@cornell.edu]
 - Angélica B. Sanchez^[Cornell University]
 - Emily O’Neil^[Cornell University]
 - Robyn M. Underwood^[The Pennsylvania State University]
 - Margarita M. López-Uribe^[The Pennsylvania State University]
 - Scott McArt^[Cornell University]
output: 
  html_document:
    code_folding: show
    highlight: tango
---

```{r setup, message=F}
library(tidyverse)      # Easier data manipulation
library(readxl)         # Import Excel files directly
library(sf)             # Spatial data
library(crawlUtils)     # Provides function to expand st_bbox limits
library(basemaps)       # Downloads base map for ggplot
# library(usmap)        # US map data
library(ggspatial)      # Provides lengend scale and north for map
library(ggrepel)        # geom_text_repel()
library(khroma)         # Colors for heatmap
library(patchwork)      # Arrange ggplots in grids
library(ggedit)         # Ability to remove a geom for vis. abstract
library(gt)             # GTables
library(glmmTMB)        # GLMMs
library(performance)    # check_overdispersion
library(emmeans)        # Pairwise tests
library(indicspecies)   # Indicator Species Analysis 
library(vegan)          # For ordinations
# devtools::install_github("pmartinezarbizu/pairwiseAdonis/pairwiseAdonis")
library(pairwiseAdonis) # Pairwise PERMANOVA
library(MuMIn)          # AICC comparison

source("functions/std_error.R") # Standard error calc
```

## 2. Methods

### Importing and cleaning data

First, we import some basic metadata on the honey samples, pesticides, USDA organic tolerances, and experimental colonies.

```{r importMetaData, message=FALSE}
# Import metadata
meta.Honey <- read_csv(
  "data/metadata/honey-meta.csv",
  na = "na",
  col_types = "fffff",
  col_select = -Store
)
meta.Cmpds <- read_csv(
  "data/metadata/pesticide-info-OREI.csv",
  col_types = "fffcc"
)
meta.Tols <- read_csv(
  "data/metadata/pesticide-tolerances.csv",
  col_types = "fdf"
)
meta.Cols <- read_csv(
  "data/metadata/colonies-OREI.csv",
  col_types = "fffff",
  col_select = c(-Position, -Pi)
)
```

Next, we need to import the Excel files from the Cornell Chemical Ecology Core Facility and convert them to a rectangular format for analysis in R. We created a function, `read_pesticides()`, that does this. The function pivots the pesticide data and tacks on the columns containing the limits of quantification and detection. Some important steps include:

1.  Read data from the spreadsheet.
2.  Import limits of detections (reported in ng of analyte).
3.  If data reads as `n.d.` or `N/F`, replace that observation with `0` ppb. If data reads as `<LOQ`, replace it with the sample-specific LOQ value for that compound, converted to ppb. (We divide the LOQ in ng by the sample weight). Likewise, `<ULOQ` values are converted to the ULOQ value.

We also follow guidelines in [USDA Publication 2613: Responding to Results from Pesticide Residue Testing](https://www.ams.usda.gov/sites/default/files/media/2613.pdf) to determine whether residue levels in each sample exceed organic tolerances. Basically, there are established limits for Amitraz and Coumaphos in honey and wax. Residue limits for every other compound are set at 10 ppb.

```{r importExcel, message=F}
source("functions/read_pesticides.R")
# fmt: skip
data.H1.raw <- read_pesticides(
  frp_ss       = "data/pesticides/2025-04-09_BDM_Results_Project79.xlsx",
  frp_tab      = "Honey",
  frp_data     = "B4:CW77", 
  frp_lims     = "E78:CW80",
  frp_pestName = "E4:CW4",
  frp_limUnits = "ng")
# fmt: skip
data.H2.raw <- read_pesticides(
  frp_ss       = "data/pesticides/2025-04-09_BDM_Results_Project79.xlsx",
  frp_tab      = "Honey",
  frp_data     = "B83:CW156", 
  frp_lims     = "E157:CW159",
  frp_pestName = "E83:CW83",
  frp_limUnits = "ng")

# Store both honey dataframes in a list
list.H <- list(
  H1 = data.H1.raw,
  H2 = data.H2.raw
)
rm(data.H1.raw, data.H2.raw)

# We create a function that cleans up the pesticide data.
# This allows us to use the function on both batches of honey data at once
clean_pesticide_data <- function(x) {
  if (!any(grepl("ULOQ", names(x)))) {
    # If dataset reports ULOL vs ULOQ.
    # Mutate() functions below won't work unless we have an ULOQ value.
    # So we set this to NA just in case it's different from ULOQ
    ULOQ.col <- "ULOQ.ppb"
    x[[ULOQ.col]] <- NA
  }

  # <LOQs or >ULOQs get replaced with LOQ or ULOQ value, respectively
  x <- x %>%
    mutate(
      ppb = case_match(
        ppb,
        "<LOQ" ~ as.character(LOD.ppb),
        ">ULOQ" ~ as.character(ULOQ.ppb),
        .default = as.character(ppb)
      ),
      ppb = as.numeric(ppb),
      Cmpd = as.factor(Cmpd)
    )

  # Now we can drop the placeholder ULOQ column
  if (exists("ULOQ.col")) {
    x <- x %>% select(-starts_with("ULOQ"))
  }
  return(x)
}

# Clean up both batches of the honey dataset at once
list.H.clean <- map(list.H, ~ clean_pesticide_data(.x))

# Combine both files
data.H.Long <- bind_rows(list.H.clean[["H1"]], list.H.clean[["H2"]]) %>%
  separate_wider_delim(
    Sample.ID,
    delim = " ",
    names = c("Sample.Type", "Sample.ID")
  ) %>%
  mutate(
    Sample.ID = as.factor(as.integer(Sample.ID)),
    Cmpd = as.factor(Cmpd),
    ppb = as.numeric(ppb)
  ) %>%
  left_join(meta.Cmpds %>% select(Cmpd, Class.Pest), by = join_by(Cmpd)) %>%
  left_join(meta.Honey, by = join_by(Sample.ID)) %>%
  left_join(meta.Cols, by = join_by(Colony.ID)) %>%
  # fmt: skip
  select(Sample.ID, Colony.ID, Group, Brand, Apiary, Trt, Cmpd, Class.Pest, ppb,
    ends_with(".ppb")
  )

data.H.Wide <- data.H.Long %>%
  select(-Class.Pest, -ends_with(".ppb")) %>%
  pivot_wider(names_from = Cmpd, values_from = ppb)

# Clean up unused vars
rm(list.H, list.H.clean)

# Vectors we can use to consistently arrange the order of pesticides in
# plots and tables
styles.classLev <- c(
  "Miticide",
  "Antibiotic",
  "Synergist",
  "Insecticide",
  "Fungicide",
  "Herbicide"
)
styles.groupOrd <- c("OREI", "OG-HI", "OG-IMP", "CNV")
styles.group <- c(
  "OREI" = "MNG ORG: New York &\nPennsylvania",
  "OG-HI" = "ORG: Hawaii",
  "OG-IMP" = "ORG: Grocery\nImported",
  "CNV" = "CNV: Grocery"
)
```

### 2.1. Experimental apiary management

#### Figure 1. Map of the Eastern United States indicating the locations of organic apiaries in the states of New York and Pennsylvania

```{r fig--1, fig.height=5, fig.width=4, message=FALSE, warning=FALSE}
# A dataframe of apiaries and GPS coordinates.
meta.farms <- read.csv("data/landscape/apiary-locations-OREI.csv")

sf.farms <- meta.farms %>%
  st_as_sf(coords = c("Lon", "Lat"), crs = 4326)

plot_map <- function(df_coords, res, expand, fPull) {
  # Convert list of apiaries into coordinates to plot
  map.coords <- df_coords %>%
    st_transform(crs = st_crs(3857)) # basemap requires EPSG 3857 web mercator

  # Get a basemap zoomed out slightly from the apiary coordinates
  # Register for an API key at https://www.thunderforest.com/ and set the credential using
  # basemaps::set_defaults()
  map.base <- basemap_gglayer(
    ext = st_expand(st_bbox(map.coords), ef = expand),
    map_service = "mapbox",
    map_type = "outdoors",
    map_res = res,
    verbose = F
  )

  # Retrieves the extents of the map we just downloaded
  map.limits <- map.base$data %>% st_as_sf(coords = c("x", "y")) %>% st_bbox()

  # Assemble the map
  map <- ggplot(data = map.coords) +
    map.base +
    scale_fill_identity() + # Plot basemap in the colors it specifies

    # Plot apiary coordinates
    geom_sf(
      aes(geometry = geometry),
      pch = 21,
      stroke = 1,
      size = 2,
      fill = "black",
      color = "white"
    ) +

    # Set limits of map to those of basemap (hide other states)
    # and remove padding between plot and axes
    scale_x_continuous(limits = map.limits[c(1, 3)], expand = c(0, 0)) +
    scale_y_continuous(limits = map.limits[c(2, 4)], expand = c(0, 0)) +

    # North arrow
    annotation_north_arrow(
      location = "br",
      pad_y = unit(0.75, "cm"),
      pad_x = unit(0.25, "cm"),
      style = north_arrow_fancy_orienteering
    ) +

    # Add a white gradient behind scale for readability.
    # See @link https://stackoverflow.com/a/72827753/5025767
    annotation_custom(
      grob = grid::rasterGrob(
        image = colorRampPalette(c("transparent", "white"), alpha = T)(10), # Gradient
        # Anchor to bottom of plot. vjust positions bottom of rect. @ y = 0
        x = unit(0.5, "npc"),
        y = unit(0, "npc"),
        vjust = 0,
        # Gradient is 100% of plot width
        width = unit(1, "npc"),
        # Height is a multiple of the scale's Y padding
        height = 4 * unit(0.25, "cm")
      )
    ) +

    # Map scale
    annotation_scale(location = "br", pad_x = unit(0.5, "cm")) +

    labs(caption = "Base map source: Mapbox, Open Street Map") +

    # Remove axis titles and gridlines
    theme(
      axis.title = element_blank(),
      panel.grid = element_blank(),
      panel.border = element_rect(fill = NA),
      plot.caption = element_text(
        hjust = 0,
        vjust = 12,
        color = "grey40",
        size = 8
      )
    )
  # Return figure
  return(map)
}

# REMOVE before publication!!
basemaps::set_defaults(map_service = "mapbox", map_token = "pk.eyJ1IjoiYmRlbW9yYXMiLCJhIjoiY21pZ3NlOWpxMGFuNDNkcThmdmk5b2lpNCJ9.qZXzdyBN60LF-F-3wbgN1w")

# Create a spatial dataframe of farm locations and leader lines
# # fmt: skip
sf.labels <- data.frame(
  Farm.Redact = c("PA-3", "PA-2", "PA-1", "NY-3", "NY-2", "NY-1"),
  lab.lon     = c(-75,    -78.6,  -78.6,  -75.3,  -75,    -77.5),
  lab.lat     = c(41.2,   41.5,   40.5,   43.5,   42.4,   42.3)) %>% 
  st_as_sf(coords = c("lab.lon", "lab.lat"), crs = 4326)

# Create lines between apiaries and labels
sf.lines <- st_sf(
  crs = st_crs(sf.labels),
  Farm.Redact = sf.labels$Farm.Redact,
  geometry = st_sfc(mapply(
    function(p1, p2) {
      st_cast(st_union(p1, p2), "LINESTRING")
    },
    sf.labels$geometry,
    sf.farms$geometry,
    SIMPLIFY = FALSE
  ))
)

# Plot the map
(fig.1 <- plot_map(df_coords = sf.farms, res = 0.4, expand = 2) +
  geom_sf(data = sf.lines, linewidth = 0.5) +
  geom_text_repel(
    data = sf.labels,
    aes(label = Farm.Redact, geometry = geometry),
    stat = "sf_coordinates",
    bg.r = 0.2,
    bg.color = "white",
    force = 0
  ) +
  theme(plot.caption = element_text(vjust = 0)))

ggsave(
  "Figure_1.png",
  plot = fig.1,
  path = "figures",
  dpi = 500,
  width = 4,
  height = 5
)
```

#### Differences in limits between both UHPLC-MS/MS batches

```{r diffLim}
difference <- function(vec) {
  diff <- max(vec) - min(vec)
  return(diff)
}

# Get just the compounds and limits
df.limits <- data.H.Long %>%
  select(Cmpd, ends_with(".ppb")) %>%
  unique()

df.limits %>%
  arrange(Cmpd) %>% # Sorts by compound. We see there's 2 limits for each compound.
  group_by(Cmpd) %>% # for each compound,
  # Compute difference between limits
  summarise(
    across(ends_with(".ppb"), list(diff = difference)),
    .groups = "drop"
  ) %>%
  # Now, for each limit, average differences across compounds and compute std. error.
  summarise(across(ends_with("_diff"), list(mean = mean, SE = std_error))) %>%
  signif(digits = 2) %>%
  # Values are easier to read if listed vertically
  transpose(keep.names = "Difference") %>%
  rename("Value (ppb)" = V1)

# Save most conservative limit (maximum) for reporting in output tables
df.limits <- df.limits %>%
  group_by(Cmpd) %>%
  summarize(across(ends_with(".ppb"), ~ max(.)))
```

#### Table S2. List of 96 pesticides screened in honey samples

```{r tab--S2}
# Summary table by compound --------------------------------------------------------
df.cmpdSumm <- data.H.Long %>%
  group_by(Cmpd, Class.Pest) %>%
  # fmt: skip
  summarize(
      n.detect   = n_distinct(Sample.ID[ppb>0]),
      pct.detect = ifelse(n.detect > 0, n.detect / n_distinct(Sample.ID), NA),
      ppb.mean   = ifelse(n.detect > 0, mean(ppb),      NA),
      ppb.se     = ifelse(n.detect > 0, std_error(ppb), NA),
      ppb.min    = ifelse(n.detect > 0, min(ppb),       NA),
      ppb.max    = ifelse(n.detect > 0, max(ppb),       NA),
      .groups    = "drop") %>%
  arrange(desc(pct.detect)) %>%
  # Convert to factor in current order. Useful for charts using this dataframe
  mutate(
    Class.Pest = factor(Class.Pest, ordered = T, levels = styles.classLev)
  ) %>%

  # Add organic MRLS
  left_join(
    meta.Tols %>%
      select(Cmpd, MRL.H.ppm) %>%
      mutate(
        MRL.OG.ppb = MRL.H.ppm * 0.05 * 1000, # 5% of EPA, convert to ppb
        # Cmpd       = factor(Cmpd, ordered = T, levels = rev(df.cmpdSumm$Cmpd)),
        .keep = "unused"
      ),
    by = "Cmpd"
  ) %>%
  # Any compound with an undefined tolerance is set at 10ppb
  mutate(MRL.OG.ppb = ifelse(is.na(MRL.OG.ppb), 10, MRL.OG.ppb)) %>%

  # Add LOD and LOQs to summary table
  left_join(df.limits %>% select(-ULOQ.ppb), by = "Cmpd")

# Generate a nice clean table -------------------------------------------------------
df.cmpdSumm %>%
  select(-n.detect) %>%
  relocate(pct.detect, LOD.ppb, LOQ.ppb, MRL.OG.ppb, .before = ppb.mean) %>%
  # filter(ppb.mean > 0) %>%  # HIDE COMPOUNDS NOT DETECTED
  group_by(Class.Pest) %>%
  arrange(Class.Pest, desc(pct.detect)) %>%

  gt(rowname_col = "Cmpd") %>%
  tab_stubhead("Compound") %>%

  # Replace NAs with Not Detected
  sub_missing(missing_text = "ND") %>%

  fmt_number(columns = c(starts_with("ppb")), decimals = 3) %>%
  fmt_percent(columns = pct.detect, decimals = 1) %>%

  tab_spanner(label = "Amounts (ppb)", columns = 4:10) %>%
  # fmt: skip
  cols_label(
      ppb.mean   = "Mean",      ppb.se     = "SE",
      ppb.min    = "Min",       ppb.max    = "Max",
      pct.detect = "% Samples", MRL.OG.ppb = "Organic MRL",
      LOD.ppb    = "LOD",       LOQ.ppb    = "LOQ") %>% 
  tab_options(table.align = "left")
    
```

## 3. Results

### 3.0. Contamination summary

#### Summary table of exposure (not in text)

```{r tab--contSummary}
# =(1) Prep data: we need the formatted data from figs. 2 & 3 for the following table
# ===================================================================================
df.none <- df.cmpdSumm %>% filter(n.detect == 0) %>% select(Cmpd)
df.fig2.heat <- data.H.Long %>%
  # Remove compounds w/ no detections
  anti_join(df.none, by = join_by(Cmpd)) %>%

  # Organic tolerances
  left_join(
    df.cmpdSumm %>% select(Cmpd, MRL.OG.ppb),
    by = "Cmpd"
  ) %>%

  select(
    Colony.ID,
    Sample.ID,
    Apiary,
    Trt,
    Cmpd,
    Class.Pest,
    ppb,
    MRL.OG.ppb,
    Group,
    Brand
  ) %>%

  # Threshold detections based on OG tolerances
  mutate(
    Exceed.Tol = ifelse(
      ppb == 0,
      "No Detection", # 0 ppb, cmpd not detected. Otherwise,
      ifelse(ppb > MRL.OG.ppb, "Yes", "No")
    ), # check detection against tolerance

    Exceed.Tol = factor(
      Exceed.Tol,
      ordered = T,
      levels = c("Yes", "No", "No Detection")
    ),

    # Set order of groups on plots
    Group = factor(Group, ordered = T, levels = styles.groupOrd)
  )

df.fig3.summ <- data.H.Long %>%
  group_by(across(c(-Cmpd, -ends_with(".ppb"), -Class.Pest, -ppb))) %>%
  summarize(
    # Count the number of compounds where ppb > 0
    num.Cmpd = length(ppb[ppb > 0]),
    # Simply sum the total ppb
    ppb.sum = sum(ppb),
    .groups = "drop"
  ) %>%
  mutate(
    Brand = as_factor(ifelse(
      is.na(Brand),
      as.character(Apiary),
      as.character(Brand)
    ))
  ) %>%
  select(-Apiary) %>%
  mutate(Group = factor(Group, ordered = T, levels = styles.groupOrd))

# =(2) Generate a summary table for reporting results ===============================
summTab <- function(x) {
  summarize(
    x,
    sum.mean = mean(ppb.sum),
    sum.se = std_error(ppb.sum),
    sum.min = min(ppb.sum),
    sum.max = max(ppb.sum),
    N.mean = mean(num.Cmpd),
    N.se = std_error(num.Cmpd),
    N.min = min(num.Cmpd),
    N.max = max(num.Cmpd)
  )
}

bind_rows(
  df.fig3.summ %>%
    group_by(Group) %>% # Dataframe summarizing detections by group
    summTab,

  df.fig3.summ %>%
    ungroup() %>% # Dataframe that summarizes across all data
    summTab %>%
    mutate(Group = "All")
) %>%

  left_join(
    # Number of compounds detected
    bind_rows(
      df.fig2.heat %>%
        group_by(Group) %>% # In each group
        summarize(Cmpds = n_distinct(Cmpd[ppb > 0])),

      # All groups
      data.frame(
        Group = "All",
        Cmpds = df.fig2.heat %>% pull(Cmpd) %>% unique() %>% length()
      )
    ),
    by = join_by(Group)
  ) %>%
  relocate(Cmpds, .after = Group) %>%

  gt() %>%
  tab_spanner(label = "Summed amount/sample (ppb)", columns = 3:6) %>%
  tab_spanner(label = "Number of compounds/sample", columns = 7:10) %>%
  fmt_number(
    columns = starts_with("sum."),
    decimals = 2,
    drop_trailing_zeros = T
  ) %>%
  fmt_number(
    columns = starts_with("N."),
    decimals = 1,
    drop_trailing_zeros = T
  ) %>%
  cols_label(
    Cmpds ~ "Number compounds detected",
    ends_with("mean") ~ "Mean",
    ends_with("se") ~ "SE",
    ends_with("min") ~ "Min.",
    ends_with("Max") ~ "Max."
  ) %>% 
  tab_options(table.align = "left")
```

#### Figure 2. Heatmap showing overall pesticide residue content of the sampled honeys

```{r fig--2}
# Build styles for plot -------------------------------------------------------------
colors.heat <- c("grey42", color("lajolla")(49))
colors.tols <- c(
  "Yes" = color("lajolla")(3)[2],
  "No" = "grey80",
  "No Detection" = "grey40"
)

styles.heat <- list(
  theme_classic(),

  # Remove things we don't need from theme
  # fmt: skip
  theme(
    axis.ticks            = element_blank(),
    axis.text.x           = element_blank(),
    axis.title.x          = element_blank(),
    axis.title.y          = element_blank(),
    axis.line.x           = element_blank(),
    axis.line.y           = element_blank(),
    strip.background      = element_rect(fill = NA, color = NA),
    plot.caption.position = "plot",
    plot.caption          = element_text(hjust = 0, color = "grey40", 
                                         face = "italic")),

  # Remove some odd spacing between panel border and plot. See:
  # https://stackoverflow.com/a/22945857
  scale_x_discrete(expand = c(0, 0)),
  scale_y_discrete(expand = c(0, 0))
)

df.fig2.heat <- df.fig2.heat %>%
  mutate(Class.Pest = recode(Class.Pest, "Synergist" = "Syn."))

# Plot overall exposure ------------------------------------------------------------
(fig.2 <- ggplot(data = df.fig2.heat) +
  geom_tile(aes(x = Sample.ID, y = Cmpd, fill = ppb), alpha = 1) +
  facet_grid(
    Class.Pest ~ Group,
    scales = "free",
    space = "free",
    labeller = labeller(Group = styles.group)
  ) +
  scale_fill_gradientn(
    name = "Concentration\n(ppb)", # Title of the scale
    colors = colors.heat, # The colors we defined earlier
    trans = "log1p"
  ) + # Log(0) is infinite, so log(ppb+1)
  labs(caption = "Plus 80 more compounds not detected.") +
  styles.heat)

ggsave(
  "Figure_2.png",
  plot = fig.2,
  path = "figures",
  dpi = 500,
  width = 7,
  height = 5
)
```

### 3.1. How did pesticide contamination compare between sampled honeys?

#### Stats for figure 3: Comparing contamination across groups of honey

First, we use the number of compounds per sample as the response variable.

```{r stats--fig3A}
# Number of residues vs. Group -----------------------------------------------------
m.fig3A <- glmmTMB(
  num.Cmpd ~ Group + (1 | Brand),
  data = df.fig3.summ,
  family = "poisson"
)

# summary(m.fig3A)
# check_overdispersion(m.fig3A)

m.fig3ANULL <- glmmTMB(
  num.Cmpd ~ (1 | Brand),
  data = df.fig3.summ,
  family = "poisson"
)

anova(m.fig3A, m.fig3ANULL)
(stat.emm.f3A <- summary(emmeans(m.fig3A, pairwise ~ Group, type = "response")))
```

Then we look at the total amount of residues in each sample as the response variable.

```{r stats--fig3B}
# Amount of residues vs. group ------------------------------------------------------
m.fig3B <- glmmTMB(
  ppb.sum ~ Group + (1 | Brand),
  data = df.fig3.summ,
  family = "tweedie"
)

m.fig3BNULL <- glmmTMB(
  ppb.sum ~ (1 | Brand),
  data = df.fig3.summ,
  family = "tweedie"
)

anova(m.fig3B, m.fig3BNULL)
(stat.emm.f3b <- summary(emmeans(m.fig3B, pairwise ~ Group, type = "response")))
```

#### Figure 3. Comparison of the number of pesticide residues in sampled honey and the summed amount of residues per sample

```{r fig--3}
# Define plot styles 
styles.colors <- color("davos", reverse = T)(6)[2:5]

# Significance labels
# fmt: skip
df.fig3.signif <- tibble(
  Sample.Type  = rep("Honey", 4),
  Group        = c("OG-HI", "OG-IMP", "CNV", "OREI"),
  Contrast.Nr  = c("a", "a", "b", "a"),
  y.Nr         = rep(7, 4),
  Contrast.Amt = c("ab", "a", "b", "a"),
  y.Amt        = rep(30, 4)
)

# Build plots -------------------------------------------------------------------
fig.3a <- ggplot(
  data = stat.emm.f3A$emmeans,
  aes(x = Group, y = rate, fill = Group)
) +
  geom_col(
    position = position_dodge(0.9),
    width = 0.8,
    color = "black",
    alpha = 1
  ) +
  geom_jitter(
    data = df.fig3.summ,
    aes(y = num.Cmpd),
    position = position_jitter(height = 0.01, width = 0.2),
    alpha = 1,
    shape = 21,
    color = "black"
  ) +
  geom_errorbar(
    aes(ymin = rate - SE, ymax = rate + SE),
    width = 0.1,
    linewidth = 1.8,
    color = "white"
  ) +
  geom_errorbar(
    aes(ymin = rate - SE, ymax = rate + SE),
    width = 0.1,
    linewidth = 1
  ) +
  geom_text(
    data = df.fig3.signif,
    aes(x = Group, y = y.Nr, label = Contrast.Nr)
  ) +
  ylab("Number of residues")

fig.3b <- ggplot(
  data = stat.emm.f3b$emmeans,
  aes(x = Group, y = response, fill = Group)
) +
  geom_col(
    position = position_dodge(0.9),
    width = 0.8,
    color = "black",
    alpha = 1
  ) +
  geom_jitter(
    data = df.fig3.summ,
    aes(y = ppb.sum),
    position = position_jitter(height = 0.01, width = 0.2),
    alpha = 1,
    shape = 21,
    color = "black"
  ) +
  geom_errorbar(
    aes(ymin = response - SE, ymax = response + SE),
    width = 0.1,
    linewidth = 1.8,
    color = "white"
  ) +
  geom_errorbar(
    aes(ymin = response - SE, ymax = response + SE),
    width = 0.1,
    linewidth = 1
  ) +
  geom_text(
    data = df.fig3.signif,
    aes(x = Group, y = y.Amt, label = Contrast.Amt)
  ) +
  ylab("Total residue amounts (ppb)")

(fig.3a /
  fig.3b +
  plot_layout(axis_titles = "collect_x") &
  coord_trans(y = "log1p") &
  scale_x_discrete(labels = styles.group) &
  scale_fill_manual(values = styles.colors) &
  xlab("Type of honey") &
  theme_classic() &
  theme(legend.position = "none")) +
  plot_annotation(tag_levels = 'A') 

ggsave(
  "Figure_3.png",
  plot = last_plot(),
  path = "figures",
  dpi = 500,
  width = 7,
  height = 5
)
```

#### Table S3. Positive compound detections within each group of sampled honey

```{r tab--S3}
df.fig2.heat %>%
  group_by(Cmpd, Class.Pest, Group) %>%
  # fmt: skip
  summarize(
    n.detects   = length(Cmpd[ppb > 0]),
    pct.detect  = n.detects / n_distinct(Sample.ID),
    mean        = mean(ppb),
    se          = std_error(ppb),
    max         = max(ppb),
    MRL.OG.ppb  = first(MRL.OG.ppb),
    n.exceedTol = length(Cmpd[ppb >= MRL.OG.ppb]),
    .groups = "drop"
  ) %>%
  arrange(Group, desc(n.detects)) %>%
  relocate(MRL.OG.ppb, n.exceedTol, .after = Class.Pest) %>%
  filter(n.detects > 0) %>%
  group_by(Group) %>%
  mutate(Group = recode(Group, !!!styles.group)) %>%

  gt(rowname_col = "Cmpd") %>%
  tab_stubhead("Compound") %>%
  fmt_percent(columns = 7, decimals = 1) %>%
  fmt_number(columns = 8:10, decimals = 2) %>%
  # fmt: skip
  cols_label(
    Class.Pest  = "Class",
    n.detects   = "n",
    pct.detect  = "%",
    mean        = "Mean",
    se          = "SE",
    max         = "Max",
    MRL.OG.ppb  = "Organic MRL",
    n.exceedTol = "n > MRL"
  ) %>%
  tab_spanner(label = "Detections", columns = 4:7) %>%
  tab_spanner(label = "Amounts (ppb)", columns = 8:10) %>% 
  tab_options(table.align = "left")
```

#### Figure 4. Non-metric multidimensional scaling (NMDS) ordination plot showing differences in contamination profiles between groups of honey.

```{r fig--4, message=FALSE}
meta.Ord <- meta.Honey %>%
  select(Sample.ID, Group) %>%
  mutate(Group = factor(Group, ordered = T, levels = styles.groupOrd)) %>%
  rename(Groups = Group)

# Data for NMDS --------------------------------------------------------------------
# See @link https://stackoverflow.com/a/65609236/5025767
df.fig4.NMDS <- data.H.Wide %>%
  column_to_rownames('Sample.ID') %>%
  select(-c(Colony.ID:Trt)) %>%
  filter(!if_all(everything(.), ~ . == 0)) %>% # Remove samples w/ no detections.
  select(-one_of(df.none %>% pull())) # Removes compounds w/ no detections

# Indicator Species Analysis -------------------------------------------------------
# See @link https://uw.pressbooks.pub/appliedmultivariatestatistics/chapter/isa/

# =(1)= Create clustering vector.
# Length of cluster vector MUST equal number of rows in df.fig4.NMDS
stat.ISA.grp <- meta.Ord %>%
  inner_join(
    df.fig4.NMDS %>% rownames_to_column("Sample.ID"),
    by = join_by(Sample.ID)
  ) %>%
  pull(Groups, Sample.ID)

# =(2)= Run the ISA.
set.seed(42) # Reproducibility
stat.ISA <- multipatt(x = df.fig4.NMDS, cluster = stat.ISA.grp)

# =(3)= Extract indicator species/compounds from the ISA
stat.ISA.tab <- stat.ISA$sign %>%
  select(-index) %>%

  # If compound is an indicator, replace value in table with group it indicates
  mutate(across(
    starts_with("s."),
    ~ ifelse(
      . == 1,
      gsub(
        "s.",
        "",
        cur_column()
      ),
      NA
    )
  )) %>%

  # Combine indicator groups into a single string, matching format from summary()
  unite(Groups, starts_with("s."), sep = "+", na.rm = T) %>%
  rownames_to_column("Cmpd") %>%

  # Only use significant compounds going forward
  filter(p.value <= 0.05) %>%

  # Lookup A & B values from ISA output
  rowwise() %>%
  mutate(
    A = as.data.frame(stat.ISA$A)[Cmpd, Groups],
    B = as.data.frame(stat.ISA$B)[Cmpd, Groups]
  ) %>%
  ungroup() %>%
  relocate(c(A, B), .before = stat) %>%

  # Format for display
  arrange(desc(stat)) %>%
  group_by(Groups)

# Run NMDS --------------------------------------------------------------------------
MDS.path <- "cache/nmds-result.rds"

if (!file.exists(MDS.path)) {
  # If the NMDS result does NOT exist, make it!
  set.seed(42) # Ensures reproducibility
  stat.MDS <- metaMDS(
    comm = df.fig4.NMDS,
    autotransform = F,
    distance = "bray",
    engine = "monoMDS",
    k = 2,
    model = "global",
    maxit = 999,
    trymax = 500,
    wascores = T,
    expand = T,
    noshare = F
  )
  saveRDS(stat.MDS, file = MDS.path)
} else {
  # The file exists, read data from it.
  stat.MDS <- readRDS(file = MDS.path)
}

stat.ISA.indic <- stat.ISA.tab %>% # Group col must be a factor to plot correctly
  mutate(Groups = factor(Groups, levels = levels(stat.ISA.grp))) %>%
  select(Cmpd, Groups)

source("functions/plot_NMDS.R")

(fig.4 <- plot_NMDS(
  MDS = stat.MDS,
  grp = stat.ISA.grp,
  indic = stat.ISA.indic,
  labs = styles.group,
  colors = lighten(styles.colors, 0.2)
)[[1]])

ggsave(
  "Figure_4.png",
  plot = fig.4,
  path = "figures",
  dpi = 500,
  width = 7,
  height = 5
)
```

#### Table S4.Pairwise PERMANOVA comparing dissimilarity in composition of pesticides between groups of honey samples.

```{r tab--S4}
adonis2(df.fig4.NMDS ~ stat.ISA.grp, method = "bray")

# Now do a pairwise PERMANOVA to see which groups differ
pairwise.adonis(df.fig4.NMDS, factors = stat.ISA.grp) %>%
  select(-Df, -p.value, -sig) %>%
  gt() %>%
  fmt_number(decimals = 3) %>%
  cols_label(
    pairs = "Pairs",
    F.Model = "F model",
    R2 = html("R<sup>2</sup>"),
    p.adjusted = "P adjusted"
  ) %>% 
  tab_options(table.align = "left")
```

#### Table S5. Result of indicator species analysis (ISA) describing the degree of association between groups of wax samples. 

```{r tab--S5}
# Returns list of indicator species in each group in a readable format
# stat.ISA.summary <- summary(stat.ISA, indvalcomp = T)
gt(stat.ISA.tab) %>%
  fmt_number(decimals = 3) %>%
  cols_label(Cmpd = "Compound", stat = "IV", p.value = "p") %>% 
  tab_options(table.align = "left")
```

### 3.2. Did the content of the sampled honey exceed USDA tolerances for organic production?

#### Figure 5. Samples exceeding surveillance MRLs for organic honey.

```{r fig5}
# Prepare data ----------------------------------------------------------------
df.fig5A.MRLHeat <- df.fig2.heat %>%
  group_by(Cmpd) %>%
  filter(any(Exceed.Tol == "Yes")) %>%
  mutate(Cmpd = case_match(Cmpd, "Piperonyl butoxide" ~ "PBO", .default = Cmpd))

df.fig5B.MRL <- df.fig2.heat %>%
  group_by(Sample.ID, Group) %>%
  summarize(
    Sample.Exceed = ifelse(any(Exceed.Tol == "Yes"), "Yes", "No"),
    .groups = "drop"
  )

df.fig5B.signif <- tibble(
  Group = c("OG-HI", "OG-IMP", "CNV", "OREI"),
  Contrast.MRL = c("b", "ab", "b", "a"),
  y.MRL = rep(0.9, 4)
)

# Fig 5A: Heatmap showing samples above tolerance --------------------------------
fig.5A <- ggplot(df.fig5A.MRLHeat) +
  geom_tile(aes(x = Sample.ID, y = Cmpd, fill = Exceed.Tol), alpha = 1) +
  facet_grid(
    Class.Pest ~ Group,
    scales = "free",
    space = "free",
    labeller = labeller(Group = styles.group)
  ) +
  scale_fill_manual(name = "Exceeds organic\nMRLs?", values = colors.tols) +
  styles.heat +
  theme(legend.position = "left", plot.caption.position = "panel") +
  labs(caption = "Plus 93 more compounds not exceeding MRLs.")

# Fig 5B: Plot w/ proportion of samples above MRL ---------------------------------
fig.5B <- ggplot(data = df.fig5B.MRL, aes(x = Group, fill = Sample.Exceed)) +
  geom_bar(position = "fill") +
  geom_jitter(
    aes(y = ifelse(Sample.Exceed == "Yes", 1, 0)),
    position = position_jitter(height = 0.01, width = 0.3),
    shape = 1,
    alpha = 0.6,
    color = "black"
  ) +
  scale_x_discrete(labels = styles.group) +
  scale_fill_manual(name = "Exceeds organic\nMRLs?", values = colors.tols) +
  ylab("\nProp. of samples >MRL\n") +
  theme_classic() +
  theme(legend.position = "none")

# Assemble combined figure
((fig.5A) /
  free(fig.5B) +
  plot_layout(heights = c(2, 3)) +
  plot_annotation(tag_levels = 'A'))

ggsave(
  "Figure_5.png",
  plot = last_plot(),
  path = "figures",
  dpi = 500,
  width = 7,
  height = 5
)
```

#### Figure 5B for visual abstract 

```{r fig--5b-abstract, fig.height=1.5, fig.width=3.75, message=FALSE}
(fig.5B.abs <- remove_geom(fig.5B, "point") +
  scale_x_discrete(
    labels = c(
      "OREI" = "N.E. USA",
      "OG-HI" = "Hawaii",
      "OG-IMP" = "Organic",
      "CNV" = "Conventional"
    )
  ) +
  ylab("p(>MRL)") +
  theme(axis.title.x = element_blank()))

ggsave(
  "Abstract_Fig5B.png",
  plot = fig.5B.abs,
  path = "figures",
  dpi = 500,
  width = 3.75,
  height = 1.5
)
```

### 3.3. Did landscape composition predict whether detected pesticide exposure?

Here, we use the [`CropScapeR`](https://github.com/cbw1243/CropScapeR) package to download the data directly from R. We create a function, called `get_apiary_CDL()` that makes this process a little easier. Given a dataframe of apiary coordinates (columns `Apiary`, `Lon`, `Lat`), it will return a dataframe of percentages of each crop/landscape type within each buffer. For optimization, the function also accepts inputs of `gc_shp` (T/F, outputs a shapefile of the buffer), `gc_tiff` (whether to save TIFFs of the buffered CDL), `gc_CDL` (T/F, useful if we want to save shapefiles but not actually download data yet), and `gc_log`, (T/F, whether the function should log progress to the console).

#### Table S6. Landscape composition within a 3 km radius of each of the 6 apiaries in 2024. 

```{r tab--S6}
# = (1) Download CDL data ===========================================================
path.CDL <- "cache/cdl-cropscape-out.csv"

# If the downloaded CDL data does NOT exist, create it! If it DOES exist, load it!
if (!file.exists(path.CDL)) {
  source("functions/get_apiary_CDL.R")

  CDL.OREI.1km <- get_apiary_CDL(
    meta.farms,
    gc_rad = 1,
    gc_yr = 2024,
    gc_dTol = 40
  )
  CDL.OREI.3km <- get_apiary_CDL(
    meta.farms,
    gc_rad = 3,
    gc_yr = 2024,
    gc_dTol = 75
  )
  CDL.OREI.6km <- get_apiary_CDL(
    meta.farms,
    gc_rad = 6.4,
    gc_yr = 2024,
    gc_dTol = 140
  )

  data.CDL <- bind_rows(CDL.OREI.1km, CDL.OREI.3km, CDL.OREI.6km)

  rm(CDL.OREI.1km, CDL.OREI.3km, CDL.OREI.6km)

  write_csv(CDL, path.CDL)
} else {
  data.CDL <- read_csv(path.CDL, col_types = "ffffd")
}
rm(path.CDL)

# = (2) Classify habitat ============================================================

# Generate a list to classify manually
# data.CDL %>% select(Crop) %>% unique() %>%
#   write_csv("cdl-crops.csv")

# Read the classified crops
meta.cropHab <- read_csv(
  "data/metadata/cdl-crops-classified.csv",
  col_types = "ff"
)

# = (3) Create a dataframe combining contamination + landscape data =================
df.landscape <- left_join(
  # Join just the New York and Pennsylvania honey data
  data.H.Long %>%
    filter(Group == "OREI") %>%
    group_by(Apiary, Trt, Colony.ID) %>%
    summarise(
      ppb.sum = sum(ppb),
      num.Cmpd = length(ppb[ppb > 0]),
      .groups = "drop"
    ),

  # with the classified habitat dataframe
  data.CDL %>%
    left_join(meta.cropHab, by = "Crop") %>%
    group_by(Apiary, Year, Rad.km, Habitat) %>%
    summarize(Pct.Habitat = sum(Pct), .groups = "drop"),

  by = join_by(Apiary),
  relationship = "many-to-many"
) %>%

  # Wider format
  pivot_wider(
    names_from = Habitat,
    values_from = Pct.Habitat,
    names_prefix = "Pct.",
    values_fill = 0
  ) %>%

  pivot_wider(
    names_from = Rad.km,
    values_from = starts_with("Pct."),
    names_glue = "{.value}_{Rad.km}km"
  )

# = (4) Summary table ==============================================================
df.landscape %>%
  select(Apiary, ends_with("_3km")) %>%
  unique() %>%
  left_join(select(meta.farms, Apiary, Farm.Redact), by = join_by(Apiary)) %>%
  select(-Apiary) %>%
  relocate(Farm.Redact, .before = everything()) %>%
  arrange(Farm.Redact) %>%
  gt() %>%
  fmt_number(decimals = 2) %>%
  tab_spanner(label = "Percent Habitat", columns = 2:5) %>%
  # fmt: skip
  cols_label(
    Farm.Redact  = "Apiary",
    Pct.Ag_3km   = "Ag",
    Pct.Semi_3km = "Semi",
    Pct.Dev_3km  = "Dev",
    Pct.Nat_3km  = "Nat"
  ) %>%
  tab_options(table.align = "left")
```

#### Table S7. Summary of GLMMs used to examine the relationship between landscape composition and pesticide contamination in New York and Pennsylvania honey

```{r tab--S7, message=FALSE}
# fmt: skip
m.land.sum     <- glmmTMB(ppb.sum ~ Pct.Ag_1km + Pct.Ag_3km + Pct.Ag_6.4km + 
                          Pct.Semi_1km + Pct.Semi_3km + Pct.Semi_6.4km + Pct.Dev_1km + 
                          Pct.Dev_3km + Pct.Dev_6.4km + (1|Apiary), 
                          data   = df.landscape,
                          family = "tweedie",
                          na.action = "na.fail")
# fmt: skip
m.land.sumNULL <- glmmTMB(ppb.sum ~ (1|Apiary), 
                          data   = df.landscape,
                          family = "tweedie",
                          na.action = "na.fail")
# fmt: skip
m.land.num     <- glmmTMB(num.Cmpd ~ Pct.Ag_1km + Pct.Ag_3km + Pct.Ag_6.4km + 
                          Pct.Semi_1km + Pct.Semi_3km + Pct.Semi_6.4km + Pct.Dev_1km + 
                          Pct.Dev_3km + Pct.Dev_6.4km + (1|Apiary), 
                          data   = df.landscape,
                          family = "poisson",
                          na.action = "na.fail")
# fmt: skip
m.land.numNULL <- glmmTMB(num.Cmpd ~ (1|Apiary), 
                          data   = df.landscape,
                          family = "poisson",
                          na.action = "na.fail")

m.test <- glmmTMB(num.Cmpd ~ Pct.Ag_1km + (1|Apiary), 
                          data   = df.landscape,
                          family = "poisson",
                          na.action = "na.fail")

# Function implements dredge() with custom outputs:
# R^2 and results from a likelihood ratio test
# It also saves results in a table for publication
do_dredge <- function(model, nModel) {
  out <- dredge(
    model,
    m.lim = c(0, 1),
    extra = list(
      # fmt: skip
      "Rsq" = function(x) r.squaredLR(x, nModel),
      "LRtest" = function(x) {
        anova <- anova(x, nModel)
        c(
          "Chisq" = anova$Chisq[2],
          "df" = anova$`Chi Df`[2],
          "p" = anova$`Pr(>Chisq)`[2]
        )
      },
      "model.int" = function(x) fixef(x)$cond[1] %>% unname(),
      "model.slope" = function(x) fixef(x)$cond[2] %>% unname()
    )
  )

  tab <- out %>%
    # I'll convert the wide output from dredge() and list the predictor(s) in a column
    # First, column names need to be clean
    rename_with(~ make.names(.) %>% str_remove("\\.$")) %>%
    select(-cond..Int., -disp..Int.) %>%
    # If we have a numeric value for the predictor, replace value with the predictor
    mutate(across(
      starts_with("cond."),
      ~ ifelse(
        !is.na(.),
        gsub("cond.", "", cur_column()),
        NA
      )
    )) %>%
    # Combine predictor names into single column
    unite(Predictor, starts_with("cond."), sep = " + ", na.rm = T) %>%
    # Remove null model and row names
    mutate(Predictor = ifelse(Predictor == "", "Null model", Predictor)) %>%
    remove_rownames()

  return(list(table = tab, models = out))
}

# Run dredge and save output
stat.dredge.S <- do_dredge(m.land.sum, m.land.sumNULL)
stat.dredge.N <- do_dredge(m.land.num, m.land.numNULL)

# Save summary table output from drege
df.land.dredge <- bind_rows(
  stat.dredge.S$table %>%
    mutate(Response = "Sum", .before = Predictor),

  stat.dredge.N$table %>%
    mutate(Response = "Num", .before = Predictor)
)

df.land.dredge %>%
  select(Response, Predictor, model.slope, starts_with("LRtest"), AICc, delta) %>%

  # Format data within table
  separate_wider_delim(
    Predictor,
    delim = "_",
    names = c("Habitat", "Radius"),
    too_few = "align_start"
  ) %>%

  mutate(
    Response = case_match(
      Response,
      "Sum" ~ "Additive amount of residues",
      "Num" ~ "Number of compounds per sample"
    ),
    Habitat = case_match(
      Habitat,
      "Pct.Semi" ~ "Seminatural",
      "Pct.Dev" ~ "Developed",
      "Pct.Ag" ~ "Agricultural",
      .default = Habitat
    ),
    model.rel = case_match(
      as.character(sign(model.slope)),
      "1" ~ "Positive",
      "-1" ~ "Negative"
    )
  ) %>% 
  select(-model.slope) %>% 
  relocate(model.rel, .after = Radius) %>% 
  gt(groupname_col = "Response") %>%
  tab_options(row_group.as_column = T, table.align = "left") %>%
  cols_width(Response ~ "160px") %>% 
  tab_stubhead("Response") %>%
  tab_spanner(label = "Predictor", columns = 2:3) %>%
  cols_label(
    model.rel = "Relationship",
    LRtest.Chisq = html("&Chi;<sup>2</sup>"),
    LRtest.df = "df",
    LRtest.p = "p",
    delta = html("&Delta;AICc")
  ) %>%
  fmt_number(columns = c(5, 7:9), decimals = 3) %>%
  tab_style(
    style = list(cell_text(weight = "bold")),
    locations = cells_body(columns = LRtest.p, rows = LRtest.p <= 0.05)
  )
```

#### Figure S2. Visualizing results from landscape model building

```{r fig--S2, fig.height=6, fig.width=6}
# Wrangle wide data for the facetted plot.
# Use Habitat and buffer radius as columns
# To plot regression line from glmm (I saved the slope and intercept in 
# df.land.dredge), make a dataframe of these values
# -----------------------------------------------------------------------------------
df.figS2 <- df.landscape %>%
  select(-starts_with("Pct.Nat")) %>% 
  pivot_longer(
    !c(Apiary:Year),
    names_to = c("Habitat", "Rad.km"),
    names_pattern = "Pct.(.*)_(.*)km",
    values_to = "Pct"
  ) %>%
  mutate(
    Habitat = case_match(
      Habitat,
      "Ag" ~ "Agricultural",
      "Semi" ~ "Seminatural",
      "Dev" ~ "Developed"
    )
  )

# Function to label facets ----------------------------------------------------------
facet_lab <- function(s) {
  # fmt: skip
  paste(s, ifelse(suppressWarnings(is.na(as.numeric(s))), "", "km")
  )
}

# Elements shared by both plots ----------------------------------------------------
styles.landColor <- darken(styles.colors[1], amount = 0.2)

styles.figS2 <- list(
  stat_smooth(
    method = "glm",
    formula = y ~ x,
    color = styles.landColor,
    fill = styles.landColor
  ),
  geom_point(alpha = 0.15),
  facet_grid(
    Rad.km ~ Habitat,
    scales = "free",
    labeller = as_labeller(facet_lab)
  ),
  theme_bw(),
  theme(
    strip.background = element_rect(fil = NA, color = NA),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  ),
  xlab("Percent Habitat"),
  # The "secondary axis" label labels the vertical facets
  scale_y_continuous(
    sec.axis = sec_axis(transform = ~., breaks = NULL, name = "Buffer Radius")
  )
)

# Build plots ----------------------------------------------------------------------
((ggplot(df.figS2, aes(x = Pct, y = ppb.sum)) +
  ylab("Total residue amounts (ppb)")) /

  (ggplot(df.figS2, aes(x = Pct, y = num.Cmpd)) +
    ylab("Number of residues"))) +
  plot_annotation(tag_levels = 'A') +
  plot_layout(axis_titles = "collect_x") &
  styles.figS2
```

what if we got the actual prediction?

```{r fig.height=6, fig.width=6, warning=FALSE}

plot_landscape <- function(
  models = df.land.dredge,
  dredge = stat.dredge.N,
  points = df.figS2,
  resp_subset = "Num",
  y_var = "num.Cmpd"
) {
  predictions <- data.frame()

  # for loop
  for (n in 2:nrow(filter(models, Response == resp_subset))) {
    # Retrieve predictor we should generate predictions for
    term <- filter(models, Response == resp_subset)$Predictor[n]

    # Retrieves model from dredge output. Second row of stat.dredge.N
    get.models(dredge$models, subset = n)[[1]]

    # generates prediction df
    predict <- ggpredict(
      get.models(dredge$models, subset = n)[[1]],
      terms = term,
      bias_correction = T
    ) %>%
      as.data.frame() %>%
      select(x, predicted, conf.low, conf.high) %>%
      mutate(Predictor = term)

    # Add new set of predictions to our dataframe
    predictions <- bind_rows(predictions, predict)

    # Track progress
    print(paste("Predicted model", n))
  }

  # Format the dataframe for plotting
  predictions <- predictions %>%
    separate_wider_regex(
      cols = Predictor,
      c("Pct.", Habitat = ".*", "_", Rad.km = ".*", "km")
    ) %>%
    mutate(
      Habitat = case_match(
        Habitat,
        "Ag" ~ "Agricultural",
        "Semi" ~ "Seminatural",
        "Dev" ~ "Developed"
      )
    )

  # Construct the plot
  plot <- ggplot(points) +
    ylab("Total residue amounts (ppb)") +
    facet_grid(
      Rad.km ~ Habitat,
      scales = "free",
      labeller = as_labeller(facet_lab)
    ) +
    geom_ribbon(
      data = predictions,
      aes(x = x, ymin = conf.low, ymax = conf.high),
      alpha = 0.4,
      fill = styles.landColor,
    ) +
    geom_line(
      data = predictions,
      aes(x = x, y = predicted),
      color = styles.landColor
    ) +
    geom_point(aes(x = Pct, y = .data[[y_var]]), alpha = 0.15) +
    theme_bw() +
    theme(
      strip.background = element_rect(fil = NA, color = NA),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank()
    ) +
    xlab("Percent Habitat") +
    # The "secondary axis" label labels the vertical facets
    scale_y_continuous(
      sec.axis = sec_axis(transform = ~., breaks = NULL, name = "Buffer Radius")
    )

  return(plot)
}

fig.S2A <- plot_landscape(
  models = df.land.dredge,
  dredge = stat.dredge.N,
  points = df.figS2,
  resp_subset = "Num",
  y_var = "num.Cmpd"
)

fig.S2B <- plot_landscape(
  models = df.land.dredge,
  dredge = stat.dredge.S,
  points = df.figS2,
  resp_subset = "Sum",
  y_var = "ppb.sum"
)

fig.S2A / fig.S2B  +
  plot_annotation(tag_levels = 'A') +
  plot_layout(axis_titles = "collect_x")
```


